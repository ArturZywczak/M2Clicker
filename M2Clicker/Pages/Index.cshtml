@page
@model IndexModel
@{
    ViewData["Title"] = "Home page";
}

<div class="text-center">

    <canvas id="myTestCanvas" width="400" height="400" style="border:1px solid #000000;">
        Your browser does not support the HTML canvas tag.
    </canvas>
    <canvas id="myCanvas" width="400" height="400" style="border:1px solid #000000;">
        Your browser does not support the HTML canvas tag.
    </canvas>

</div>


<script src="~/js/helpers.js" asp-append-version="true"></script>
<script src="~/js/models.js" asp-append-version="true"></script>
<script>
    const player = new Player("Gracz", new Position(200,250));
    const spawnPoints = [{ x: 100, y: 100, mobGroups: [] }, 
        { x: 300, y: 100, mobGroups: [] }, 
        { x: 100, y: 300, mobGroups: [] }, 
        { x: 300, y: 300, mobGroups: [] }];

    
    spawnPoints.forEach(e => {
        for(var i = 0; i<3; i++) {
            var temp = getRandomCordsInRadius(e.x, e.y, 80);
            e.mobGroups.push({ groupId: i, mobs: [], x: temp[0] , y: temp[1] });
            for (var j = 0; j<3; j++){
                var temp = getRandomCordsInRadius(e.mobGroups[i].x, e.mobGroups[i].y, 40);
                e.mobGroups[i].mobs.push({mobId: j, mobName: "Pies", mobHp : 100, x: temp[0], y: temp[1], activity: 0, 
                toX: 0, toY: 0, steps: 0, a: 0, b: 0});
            }
        }
    });
    //BIG INIT TODO
    function onInit(){
        //Pobierz lokacje gracza i dodaj do obiektu

        //Pobierz spawnpointy i stwórz z nich listę obiektów

        //Zespawnuj mobki na niektórych spawnpointach
    }

    { //TEST HERE
        var tCanvas = document.getElementById("myTestCanvas");
        var tCtx = tCanvas.getContext("2d");

    
        let offset = 0;

        function init() {
            tCtx.fillRect(175, 175, 50, 50);
            tCtx.clearRect(175, 175, 20+offset, 20+offset);

            tCtx.beginPath();
            tCtx.moveTo(75, 50);
            tCtx.lineTo(100, 75);
            tCtx.lineTo(100, 25);
            tCtx.fill();

            tCtx.beginPath();
            tCtx.strokeStyle = 'orange';
            tCtx.moveTo(175, 50);
            tCtx.lineTo(200, 75);
            tCtx.lineTo(200, 25);
            tCtx.lineTo(175,50);
            tCtx.stroke();
            tCtx.closePath();

            tCtx.beginPath();
            tCtx.moveTo(275, 50);
            tCtx.lineTo(300, 75);
            tCtx.lineTo(300, 25);
            tCtx.lineTo(275, 50);
            tCtx.stroke();
            tCtx.closePath();
            setTimeout(test, 200);
        }

        function test(){
            offset++;
            if (offset>20) offset = 0;
            init();

        }

        init();
    }

    var canvas = document.getElementById("myCanvas");
    var ctx = canvas.getContext("2d");

    canvas.addEventListener("click", onClick);

    function onClick(e){

        player.pos.goto(getMousePos(canvas,e));

    }

    function drawAll(){
        ctx.fillStyle= "black";
        ctx.fillRect(0,0, canvas.clientWidth, canvas.clientHeight)
        drawPlayer();
        drawSpawnPoints();
        drawMobs();

        setTimeout(mapAnim, 20);
    }

    function drawPlayer(){

        ctx.fillStyle = "blue";
        ctx.fillRect(player.pos.x - 2.5 ,player.pos.y - 2.5 ,5,5);
    }

    function drawSpawnPoints(){

        spawnPoints.forEach(e => {

            ctx.fillStyle = "yellow";
            ctx.fillRect(e.x - 2.5 , e.y - 2.5 , 5, 5);
            
            ctx.beginPath();
            ctx.strokeStyle = "white";
            ctx.arc(e.x, e.y, 45, 0, 2 * Math.PI);
            ctx.stroke(); 

            ctx.beginPath();
            ctx.strokeStyle = "pink";
            ctx.arc(e.x, e.y, 80, 0, 2 * Math.PI);
            ctx.stroke(); 

        });
    }

    function drawMobs(){

        spawnPoints.forEach(e => {
            

            e.mobGroups.forEach(f => {

                ctx.fillStyle = "pink";
                ctx.fillRect(f.x - 2.5 , f.y - 2.5 , 5, 5);

                ctx.beginPath();
                ctx.strokeStyle = "red";
                ctx.arc(f.x, f.y, 40, 0, 2 * Math.PI);
                ctx.stroke(); 

                f.mobs.forEach(g => {

                    if (((player.pos.x - g.x) * (player.pos.x - g.x) + (player.pos.y - g.y) * (player.pos.y - g.y)) < Math.pow(20,2) ) ctx.fillStyle = "orange";
                    else ctx.fillStyle = "red";
                    ctx.fillRect(g.x, g.y, 5, 5);

                });

            });

        });

    }

    function mapAnim(){

        if (player.pos.walking == true) player.pos.run();

        spawnPoints.forEach(e =>{

            e.mobGroups.forEach(f =>{
                
                f.mobs.forEach(g => {

                    if(g.activity==0) {

                        if (Math.random()> 0.995) {
                            g.activity = 1;
                            var temp = getRandomCordsInRadius(f.x, f.y, 40);
                            g.toX = temp[0]; g.toY = temp[1];

                            g.a = (g.toY-g.y)/(g.toX-g.x);
                            g.b = g.toY-(g.a*g.toX);

                            var distance = Math.pow(Math.pow(g.x - g.toX, 2) + Math.pow(g.y - g.toY, 2), 1 / 2); 
                            g.steps = Math.abs(g.toX-g.x) / Math.ceil(distance); 

                        }
                    }
                    if(g.activity == 1) {
                        
                        if (g.x != g.toX) {
                            g.x > g.toX ? g.x -= g.steps : g.x += g.steps;

                            g.y = g.a*g.x+g.b;
                            }
                        if (Math.abs(g.x - g.toX) < 1) g.activity = 0;




                    }

                });



            });
        
        });

        drawAll();
    }

    drawAll();

   

    
</script>