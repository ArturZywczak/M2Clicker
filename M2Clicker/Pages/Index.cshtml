@page
@model IndexModel
@{
    ViewData["Title"] = "Home page";
}

<div class="text-center">

    <canvas id="myTestCanvas" width="400" height="400" style="border:1px solid #000000;">
        Your browser does not support the HTML canvas tag.
    </canvas>
    <canvas id="myCanvas" width="400" height="400" style="border:1px solid #000000;">
        Your browser does not support the HTML canvas tag.
    </canvas>

</div>

<script>
    const player = {x:200, y:200};
    const spawnPoints = [{ x: 100, y: 100, mobGroups: [] }, 
        { x: 300, y: 100, mobGroups: [] }, 
        { x: 100, y: 300, mobGroups: [] }, 
        { x: 300, y: 300, mobGroups: [] }];

    
    spawnPoints.forEach(e => {
        for(var i = 0; i<3; i++) {
            var temp = getRandomCordsInRadius(e.x, e.y, 80);
            e.mobGroups.push({ groupId: i, mobs: [], x: temp[0] , y: temp[1] });
            for (var j = 0; j<3; j++){
                var temp = getRandomCordsInRadius(e.mobGroups[i].x, e.mobGroups[i].y, 40);
                e.mobGroups[i].mobs.push({mobId: j, mobName: "Pies", mobHp : 100, x: temp[0], y: temp[1], activity: 0, 
                toX: 0, toY: 0, steps: 0, a: 0, b: 0});
            }
        }
    });
    //BIG INIT TODO
    function onInit(){
        //Pobierz lokacje gracza i dodaj do obiektu

        //Pobierz spawnpointy i stwórz z nich listę obiektów

        //Zespawnuj mobki na niektórych spawnpointach
    }

    { //TEST HERE
        var tCanvas = document.getElementById("myTestCanvas");
        var tCtx = tCanvas.getContext("2d");

    
        let offset = 0;

        function init() {
            tCtx.fillRect(175, 175, 50, 50);
            tCtx.clearRect(175, 175, 20+offset, 20+offset);

            tCtx.beginPath();
            tCtx.moveTo(75, 50);
            tCtx.lineTo(100, 75);
            tCtx.lineTo(100, 25);
            tCtx.fill();

            tCtx.beginPath();
            tCtx.strokeStyle = 'orange';
            tCtx.moveTo(175, 50);
            tCtx.lineTo(200, 75);
            tCtx.lineTo(200, 25);
            tCtx.lineTo(175,50);
            tCtx.stroke();
            tCtx.closePath();

            tCtx.beginPath();
            tCtx.moveTo(275, 50);
            tCtx.lineTo(300, 75);
            tCtx.lineTo(300, 25);
            tCtx.lineTo(275, 50);
            tCtx.stroke();
            tCtx.closePath();
            setTimeout(test, 200);
        }

        function test(){
            offset++;
            if (offset>20) offset = 0;
            init();

        }

        init();
    }

    var canvas = document.getElementById("myCanvas");
    var ctx = canvas.getContext("2d");

    var walking = false;
    var x = 0;
    var y = 0;
    var a = 0;
    var b = 0;
    var ilekrokow;
    canvas.addEventListener("click", onClick);

    function onClick(e){

        walking = true;

        getMousePos(canvas, e);

    }

    function getMousePos(canvas, evt) {
        var rect = canvas.getBoundingClientRect();
        
        x = (evt.clientX - rect.left) / (rect.right - rect.left) * canvas.width;
        y = (evt.clientY - rect.top) / (rect.bottom - rect.top) * canvas.height;
        x = Math.round(x); y = Math.round(y);

        a = (y-player.y)/(x-player.x);
        b = y-(a*x);

        var distance = Math.pow(Math.pow(player.x - x, 2) + Math.pow(player.y - y, 2), 1 / 2); 
        ilekrokow = Math.abs(x-player.x) / Math.ceil(distance / 2); //PRĘDKOŚĆ PORUSZANIA, 10ms-1j, dlatego distance*10(aby uzyskać ms potrzebne do pokonania takiego dystansu) /20 (krok animacji jest co 20ms);
    }

    function drawAll(){
        ctx.fillStyle= "black";
        ctx.fillRect(0,0, canvas.clientWidth, canvas.clientHeight)
        drawPlayer();
        drawSpawnPoints();
        drawMobs();

        setTimeout(mapAnim, 20);
    }

    function drawPlayer(){
        ctx.fillStyle = "blue";
        ctx.fillRect(player.x - 2.5 ,player.y - 2.5 ,5,5);
    }

    function drawSpawnPoints(){

        spawnPoints.forEach(e => {

            ctx.fillStyle = "yellow";
            ctx.fillRect(e.x - 2.5 , e.y - 2.5 , 5, 5);
            
            ctx.beginPath();
            ctx.strokeStyle = "white";
            ctx.arc(e.x, e.y, 45, 0, 2 * Math.PI);
            ctx.stroke(); 

            ctx.beginPath();
            ctx.strokeStyle = "pink";
            ctx.arc(e.x, e.y, 80, 0, 2 * Math.PI);
            ctx.stroke(); 

        });
    }

    function drawMobs(){

        spawnPoints.forEach(e => {
            

            e.mobGroups.forEach(f => {

                ctx.fillStyle = "pink";
                ctx.fillRect(f.x - 2.5 , f.y - 2.5 , 5, 5);

                ctx.beginPath();
                ctx.strokeStyle = "red";
                ctx.arc(f.x, f.y, 40, 0, 2 * Math.PI);
                ctx.stroke(); 

                f.mobs.forEach(g => {

                    if (((player.x - g.x) * (player.x - g.x) + (player.y - g.y) * (player.y - g.y)) < Math.pow(20,2) ) ctx.fillStyle = "orange";
                    else ctx.fillStyle = "red";
                    ctx.fillRect(g.x, g.y, 5, 5);

                });

            });

        });

    }

    function mapAnim(){
        if (walking) {
            if (player.x != x) {
                player.x > x ? player.x -=ilekrokow : player.x +=ilekrokow;
                //if (player.y != y) player.y = a*player.x+b;
                player.y = a*player.x+b;
            }
            if (Math.round(player.x) == x && Math.round(player.y) == y) walking = false;

            player
        }

        spawnPoints.forEach(e =>{

            e.mobGroups.forEach(f =>{
                
                f.mobs.forEach(g => {

                    if(g.activity==0) {

                        if (Math.random()> 0.995) {
                            g.activity = 1;
                            var temp = getRandomCordsInRadius(f.x, f.y, 40);
                            g.toX = temp[0]; g.toY = temp[1];

                            g.a = (g.toY-g.y)/(g.toX-g.x);
                            g.b = g.toY-(g.a*g.toX);

                            var distance = Math.pow(Math.pow(g.x - g.toX, 2) + Math.pow(g.y - g.toY, 2), 1 / 2); 
                            g.steps = Math.abs(g.toX-g.x) / Math.ceil(distance); 

                        }
                    }
                    if(g.activity == 1) {
                        
                        if (g.x != g.toX) {
                            g.x > g.toX ? g.x -= g.steps : g.x += g.steps;

                            g.y = g.a*g.x+g.b;
                            }
                        if (Math.abs(g.x - g.toX) < 1) g.activity = 0;




                    }

                });



            });
        
        });

        drawAll();
    }

    drawAll();

    function getRandomInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function getRandomCordsInRadius(x, y, r) {
        let ang = Math.random() * 2 * Math.PI,
            hyp = Math.sqrt(Math.random()) * r,
            adj = Math.cos(ang) * hyp,
            opp = Math.sin(ang) * hyp;
        
        
        return [x + adj, y + opp];

    }
</script>